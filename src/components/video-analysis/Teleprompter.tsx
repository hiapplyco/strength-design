import React, { useState, useRef, useEffect } from 'react';
import { Button } from "@/components/ui/button";
import { Slider } from "@/components/ui/slider";
import { useToast } from "@/hooks/use-toast";

interface TeleprompterProps {
  script: string;
  position: number;
  setPosition: (position: number) => void;
}

interface WordSpan {
  word: string;
  isSpoken: boolean;
}

// Function to clean HTML/markdown from script for teleprompter display
const cleanScriptForTeleprompter = (script: string): string => {
  // Create a temporary div to strip HTML tags
  const tempDiv = document.createElement('div');
  tempDiv.innerHTML = script;
  
  // Get plain text content
  let cleanText = tempDiv.textContent || tempDiv.innerText || script;
  
  // Remove common markdown patterns
  cleanText = cleanText
    .replace(/#{1,6}\s+/g, '') // Remove markdown headers
    .replace(/\*\*(.*?)\*\*/g, '$1') // Remove bold markdown
    .replace(/\*(.*?)\*/g, '$1') // Remove italic markdown
    .replace(/`(.*?)`/g, '$1') // Remove inline code
    .replace(/```[\s\S]*?```/g, '') // Remove code blocks
    .replace(/\[([^\]]+)\]\([^)]+\)/g, '$1') // Remove markdown links
    .replace(/^\s*[-*+]\s+/gm, '') // Remove bullet points
    .replace(/^\s*\d+\.\s+/gm, '') // Remove numbered lists
    .replace(/\n{3,}/g, '\n\n') // Replace multiple newlines with double newlines
    .replace(/\s+/g, ' ') // Replace multiple spaces with single space
    .trim();
  
  return cleanText;
};

export const Teleprompter = ({ script, position, setPosition }: TeleprompterProps) => {
  const { toast } = useToast();
  const [speed, setSpeed] = useState(0.25); // Start with slower default speed
  const [playing, setPlaying] = useState(false);
  const [fontSize, setFontSize] = useState(32);
  const [mirrorV, setMirrorV] = useState(false);
  const [mirrorH, setMirrorH] = useState(false);
  const [showTimer, setShowTimer] = useState(false);
  const [elapsedTime, setElapsedTime] = useState(0);
  const [words, setWords] = useState<WordSpan[]>([]);
  
  const scrollRef = useRef<HTMLDivElement>(null);
  const animationRef = useRef<number>();
  const timerRef = useRef<number>();
  const lastScrollPosition = useRef(0);

  // Clean script for display
  const cleanScript = cleanScriptForTeleprompter(script);

  // Initialize words from cleaned script
  useEffect(() => {
    const wordArray = cleanScript.split(/\s+/).map(word => ({
      word,
      isSpoken: false
    }));
    setWords(wordArray);
    lastScrollPosition.current = 0;
    if (scrollRef.current) {
      scrollRef.current.scrollTo(0, 0);
    }
  }, [cleanScript]);

  useEffect(() => {
    if (playing && scrollRef.current) {
      const scroll = () => {
        if (!scrollRef.current) return;
        lastScrollPosition.current += speed;
        scrollRef.current.scrollTo(0, lastScrollPosition.current);
        
        if (setPosition) {
          setPosition(lastScrollPosition.current);
        }
        animationRef.current = requestAnimationFrame(scroll);
      };

      animationRef.current = requestAnimationFrame(scroll);
    }
    return () => {
      if (animationRef.current) {
        cancelAnimationFrame(animationRef.current);
      }
    };
  }, [playing, speed, setPosition]);

  useEffect(() => {
    if (showTimer && playing) {
      timerRef.current = window.setInterval(() => {
        setElapsedTime(prev => prev + 1);
      }, 1000);
    }
    return () => {
      if (timerRef.current) {
        clearInterval(timerRef.current);
      }
    };
  }, [showTimer, playing]);

  const togglePlay = () => setPlaying(prev => !prev);
  
  const handleReset = () => {
    setPlaying(false);
    setElapsedTime(0);
    if (scrollRef.current) {
      lastScrollPosition.current = 0;
      scrollRef.current.scrollTo(0, 0);
    }
    setWords(prevWords => prevWords.map(word => ({ ...word, isSpoken: false })));
  };

  const formatTime = (seconds: number) => {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
  };

  return (
    <div className="space-y-4">
      <div className="flex flex-col md:flex-row items-center gap-4">
        <div className="flex items-center gap-2 w-full md:w-auto">
          <label className="text-white whitespace-nowrap">Speed: {speed.toFixed(2)}x</label>
          <Slider
            value={[speed]}
            onValueChange={([value]) => setSpeed(value)}
            min={0.1}
            max={5}
            step={0.1}
            className="w-40"
          />
        </div>
        <div className="flex items-center gap-2 w-full md:w-auto">
          <label className="text-white whitespace-nowrap">Font size: {fontSize}px</label>
          <Slider
            value={[fontSize]}
            onValueChange={([value]) => setFontSize(value)}
            min={14}
            max={72}
            step={1}
            className="w-40"
          />
        </div>
      </div>

      <div className="flex flex-wrap gap-2">
        <Button 
          onClick={togglePlay}
          variant="default"
        >
          {playing ? 'Pause' : 'Play'}
        </Button>
        <Button 
          onClick={handleReset}
          variant="secondary"
        >
          Reset
        </Button>
        <Button 
          onClick={() => setMirrorV(prev => !prev)}
          variant={mirrorV ? "default" : "secondary"}
        >
          Flip Vertical
        </Button>
        <Button 
          onClick={() => setMirrorH(prev => !prev)}
          variant={mirrorH ? "default" : "secondary"}
        >
          Flip Horizontal
        </Button>
        <Button 
          onClick={() => setShowTimer(prev => !prev)}
          variant={showTimer ? "default" : "secondary"}
        >
          Timer: {showTimer ? 'ON' : 'OFF'}
        </Button>
        {showTimer && (
          <div className="flex items-center justify-center px-4 py-2 bg-primary text-primary-foreground rounded-md">
            {formatTime(elapsedTime)}
          </div>
        )}
      </div>
      
      <div 
        ref={scrollRef}
        className="mt-4 p-4 bg-black/50 rounded-lg overflow-y-auto h-[400px] relative"
      >
        <div 
          className="whitespace-pre-wrap text-center"
          style={{ 
            fontSize: `${fontSize}px`, 
            lineHeight: 1.6,
            transform: `scale(${mirrorH ? -1 : 1}, ${mirrorV ? -1 : 1})` 
          }}
        >
          {words.map((wordObj, index) => (
            <span
              key={index}
              className={`word ${wordObj.isSpoken ? 'text-blue-500' : 'text-white'} transition-colors duration-200`}
            >
              {wordObj.word}{' '}
            </span>
          ))}
        </div>
      </div>
    </div>
  );
};
